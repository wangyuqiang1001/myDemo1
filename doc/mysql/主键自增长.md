## mysql 主键自增长引发的思考

(原文参考地址:https://www.jianshu.com/p/0c452f829dd2)

自增主键是指在自增列上定义的主键。自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，索引也更紧凑。

结论: 在mysql数据库引擎是innerDB方式下,多线程并发下主键自增长是线程安全的，这个引擎模式下是语句锁。而mylsam模式下是表锁，锁全表.

innodb_autoinc_lock_mode 不同值设置是为了在数据一致性和并发度方面做的不同导向权衡，如果值为2 则会出现数据一致性问题:

而要解决这个问题，有两种思路：

一种思路是，让原库的批量插入数据语句，固定生成连续的 id 值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。

另一种思路是，在 binlog 里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是 innodb_autoinc_lock_mode 设置为 2，同时 binlog_format 设置为 row。





1. MyISAM 引擎：自增值保存在数据文件中；
2. InnoDB引擎：
3. 在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 `max(id)`，然后将 `max(id)+1` 作为这个表当前的自增值。
4. 在 MySQL 8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值。

### 二：自增长主键出现不连续的几种情况

1. 事务回滚
2. 插入时出现唯一冲突 
3. innodb_autoinc_lock_mode 值为2时

###  三: innodb_autoinc_lock_mode解析

自增 id 锁不是事务锁，在每次申请完就立马释放，以便允许其他事务可以申请。

其实，在 MySQL 5.0 版本的时候，自增锁的范围是语句级别，即一个语句申请了表自增锁，这个锁要等到该语句执行完以后才释放，在此之前其他需要申请表自增锁的语句会被阻塞。此举虽然保证了数据一致性，但是降低了并发度。（mysql8默认值是2）

在 MySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode，用户可根据实际情况定制锁策略，该参数有如下值 （默认值是 1）：

- 值为 0（Traditional，传统）时，采用传统锁模式，即采用之前 MySQL 5.0 版本的策略，所有 insert 操作都要申请自增锁，语句执行结束后才释放锁；

- 值为 1（Consecutive，连续）时：

  - 普通 insert 语句，自增锁在申请之后就马上释放；
  - 批量 insert 语句，类似 insert … select、replace...select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；

- 值为 2（Interleaved，交错）时，所有的申请自增主键的动作都是申请后就释放锁。

- 而对于批量插入数据的语句（select … insert，replace … select 和 load data 语句），MySQL 有一个批量申请自增 id 的策略（**注：该策略是导致自增 id 不连续的第三种原因。**）：

  1. 语句执行过程中，第一次申请自增 id，会分配 1 个；（可以理解为类似hashmap那种扩容机制）

  2. 1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；

  3. 2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；

  4. 依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。

     

  

  







